<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-01-29 Fri 12:24 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quantum Monte Carlo</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Anthony Scemama, Claudia Filippi" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" title="Standard" href="worg.css" type="text/css" />

<script type="text/javascript" src="org-info.js">
/**
 *
 * @source: org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in org-info.js.
 *
 * Copyright (C) 2012-2019 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "1");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Quantum Monte Carlo</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbb97b6f">1. Introduction</a></li>
<li><a href="#org623e4cb">2. Numerical evaluation of the energy</a>
<ul>
<li><a href="#orgcf2eac0">2.1. Local energy</a>
<ul>
<li><a href="#org6e4be76">2.1.1. Exercise 1</a>
<ul>
<li><a href="#org1c29fdf">2.1.1.1. Solution</a></li>
</ul>
</li>
<li><a href="#org45f3e47">2.1.2. Exercise 2</a>
<ul>
<li><a href="#org17b1476">2.1.2.1. Solution</a></li>
</ul>
</li>
<li><a href="#org41fbf18">2.1.3. Exercise 3</a>
<ul>
<li><a href="#org58a5a88">2.1.3.1. Solution</a></li>
</ul>
</li>
<li><a href="#org19beacc">2.1.4. Exercise 4</a>
<ul>
<li><a href="#orgd059715">2.1.4.1. Solution</a></li>
</ul>
</li>
<li><a href="#orgfb98bee">2.1.5. Exercise 5</a>
<ul>
<li><a href="#orgd271963">2.1.5.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6cc9505">2.2. Plot of the local energy along the \(x\) axis</a>
<ul>
<li><a href="#org969c80e">2.2.1. Exercise</a>
<ul>
<li><a href="#org1d42b6b">2.2.1.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4643440">2.3. Numerical estimation of the energy</a>
<ul>
<li><a href="#org7934633">2.3.1. Exercise</a>
<ul>
<li><a href="#orgce31e40">2.3.1.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6c8b12d">2.4. Variance of the local energy</a>
<ul>
<li><a href="#orgbb0a7be">2.4.1. Exercise (optional)</a>
<ul>
<li><a href="#orgca7c679">2.4.1.1. Solution</a></li>
</ul>
</li>
<li><a href="#org696e18d">2.4.2. Exercise</a>
<ul>
<li><a href="#orgee7fe6c">2.4.2.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6d5323b">3. Variational Monte Carlo</a>
<ul>
<li><a href="#org945932a">3.1. Computation of the statistical error</a>
<ul>
<li><a href="#org7e965d1">3.1.1. Exercise</a>
<ul>
<li><a href="#org73d2a6e">3.1.1.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org70d91fe">3.2. Uniform sampling in the box</a>
<ul>
<li><a href="#org05579fd">3.2.1. Exercise</a>
<ul>
<li><a href="#orgc64c471">3.2.1.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orga17395f">3.3. Metropolis sampling with \(\Psi^2\)</a>
<ul>
<li><a href="#org03d2480">3.3.1. Exercise</a>
<ul>
<li><a href="#org277a0d2">3.3.1.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4b2e6bb">3.4. Gaussian random number generator</a></li>
<li><a href="#orgd704542">3.5. Generalized Metropolis algorithm</a>
<ul>
<li><a href="#org107b8c2">3.5.1. Exercise 1</a>
<ul>
<li><a href="#org8b8a874">3.5.1.1. Solution</a></li>
</ul>
</li>
<li><a href="#org02c9606">3.5.2. Exercise 2</a>
<ul>
<li><a href="#org4580e2f">3.5.2.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdceacd5">4. Diffusion Monte Carlo</a>
<ul>
<li><a href="#org3941aac">4.1. Schrödinger equation in imaginary time</a></li>
<li><a href="#orge021b97">4.2. Diffusion and branching</a></li>
<li><a href="#org0d37b59">4.3. Importance sampling</a>
<ul>
<li><a href="#orgc0fb19f">4.3.1. Appendix : Details of the Derivation</a></li>
</ul>
</li>
<li><a href="#orgb90c671">4.4. Fixed-node DMC energy</a></li>
<li><a href="#org971d2c0">4.5. Pure Diffusion Monte Carlo (PDMC)</a></li>
<li><a href="#orgf89d780">4.6. Hydrogen atom</a>
<ul>
<li><a href="#orga1bc199">4.6.1. Exercise</a>
<ul>
<li><a href="#orga0bccd7">4.6.1.1. Solution</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org182141b">4.7. <span class="todo TODO">TODO</span> H<sub>2</sub></a></li>
</ul>
</li>
<li><a href="#org51ed78c">5. <span class="todo TODO">TODO</span> <code>[0/3]</code> Last things to do</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgbb97b6f" class="outline-2">
<h2 id="orgbb97b6f"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This web site is the QMC tutorial of the LTTC winter school 
<a href="https://www.irsamc.ups-tlse.fr/lttc/Luchon">Tutorials in Theoretical Chemistry</a>.
</p>

<p>
We propose different exercises to understand quantum Monte Carlo (QMC)
methods. In the first section, we propose to compute the energy of a
hydrogen atom using numerical integration. The goal of this section is
to introduce the <i>local energy</i>.
Then we introduce the variational Monte Carlo (VMC) method which
computes a statistical estimate of the expectation value of the energy
associated with a given wave function.
Finally, we introduce the diffusion Monte Carlo (DMC) method which
gives the exact energy of the hydrogen atom and of the H<sub>2</sub> molecule. 
</p>

<p>
Code examples will be given in Python and Fortran. You can use
whatever language you prefer to write the program.
</p>

<p>
We consider the stationary solution of the Schrödinger equation, so
the wave functions considered here are real: for an \(N\) electron
system where the electrons move in the 3-dimensional space,
\(\Psi : \mathbb{R}^{3N} \rightarrow \mathbb{R}\). In addition, \(\Psi\)
is defined everywhere, continuous and infinitely differentiable.
</p>

<p>
All the quantities are expressed in <i>atomic units</i> (energies,
coordinates, etc).
</p>
</div>
</div>

<div id="outline-container-org623e4cb" class="outline-2">
<h2 id="org623e4cb"><span class="section-number-2">2</span> Numerical evaluation of the energy</h2>
<div class="outline-text-2" id="text-2">
<p>
In this section we consider the Hydrogen atom with the following
wave function:
</p>

<p>
\[
  \Psi(\mathbf{r}) = \exp(-a |\mathbf{r}|)
  \]
</p>

<p>
We will first verify that, for a given value of \(a\), \(\Psi\) is an
eigenfunction of the Hamiltonian
</p>

<p>
\[
  \hat{H} = \hat{T} + \hat{V} = - \frac{1}{2} \Delta - \frac{1}{|\mathbf{r}|}
  \]
</p>

<p>
To do that, we will check if the local energy, defined as
</p>

<p>
\[
  E_L(\mathbf{r}) = \frac{\hat{H} \Psi(\mathbf{r})}{\Psi(\mathbf{r})},
  \]
</p>

<p>
is constant.
</p>


<p>
The probabilistic <i>expected value</i> of an arbitrary function \(f(x)\)
with respect to a probability density function \(p(x)\) is given by
</p>

<p>
\[ \langle f \rangle_p = \int_{-\infty}^\infty p(x)\, f(x)\,dx. \]
</p>

<p>
Recall that a probability density function \(p(x)\) is non-negative
and integrates to one:
</p>

<p>
\[ \int_{-\infty}^\infty p(x)\,dx = 1. \]
</p>


<p>
The electronic energy of a system is the expectation value of the
local energy \(E(\mathbf{r})\) with respect to the 3N-dimensional
electron density given by the square of the wave function:
</p>

\begin{eqnarray*}
E & = & \frac{\langle \Psi| \hat{H} | \Psi\rangle}{\langle \Psi |\Psi \rangle} 
    =   \frac{\int \Psi(\mathbf{r})\, \hat{H} \Psi(\mathbf{r})\, d\mathbf{r}}{\int \left[\Psi(\mathbf{r}) \right]^2 d\mathbf{r}} \\
  & = & \frac{\int \left[\Psi(\mathbf{r})\right]^2\, \frac{\hat{H} \Psi(\mathbf{r})}{\Psi(\mathbf{r})}\,d\mathbf{r}}{\int \left[\Psi(\mathbf{r}) \right]^2 d\mathbf{r}} 
    =   \frac{\int \left[\Psi(\mathbf{r})\right]^2\, E_L(\mathbf{r})\,d\mathbf{r}}{\int \left[\Psi(\mathbf{r}) \right]^2 d\mathbf{r}} 
    =   \langle E_L \rangle_{\Psi^2}
\end{eqnarray*}
</div>

<div id="outline-container-orgcf2eac0" class="outline-3">
<h3 id="orgcf2eac0"><span class="section-number-3">2.1</span> Local energy</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Write all the functions of this section in a single file :
<code>hydrogen.py</code> if you use Python, or <code>hydrogen.f90</code> is you use
Fortran.
</p>

<div class="note">
<ul class="org-ul">
<li>When computing a square root in \(\mathbb{R}\), <b>always</b> make sure
that the argument of the square root is non-negative.</li>
<li>When you divide, <b>always</b> make sure that you will not divide by zero</li>
</ul>

<p>
If a <i>floating-point exception</i> can occur, you should make a test
to catch the error.
</p>

</div>
</div>

<div id="outline-container-org6e4be76" class="outline-4">
<h4 id="org6e4be76"><span class="section-number-4">2.1.1</span> Exercise 1</h4>
<div class="outline-text-4" id="text-2-1-1">
<div class="exercise">
<p>
Write a function which computes the potential at \(\mathbf{r}\).
The function accepts a 3-dimensional vector <code>r</code> as input arguments
and returns the potential.
</p>

</div>

<p>
\(\mathbf{r}=\left( \begin{array}{c} x \\ y\\ z\end{array} \right)\), so
\[
    V(\mathbf{r}) = -\frac{1}{\sqrt{x^2 + y^2 + z^2}}
    \]
</p>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">potential</span>(r):
    # <span style="color: #b22222;">TODO</span>
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">potential</span><span style="color: #000000; background-color: #ffffff;">(r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> r(3)</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">potential</span>
</pre>
</div>
</div>

<div id="outline-container-org1c29fdf" class="outline-5">
<h5 id="org1c29fdf"><span class="section-number-5">2.1.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-1-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">potential</span>(r):
    <span style="color: #a0522d;">distance</span> = np.sqrt(np.dot(r,r))
    <span style="color: #a020f0;">assert</span> (distance &gt; 0)
    <span style="color: #a020f0;">return</span> -1. / distance
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">potential</span><span style="color: #000000; background-color: #ffffff;">(r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> r(3)</span>

  <span style="color: #228b22;">double precision</span>             ::<span style="color: #a0522d;"> distance</span>

  distance = dsqrt( r(1)*r(1) + r(2)*r(2) + r(3)*r(3) )

  <span style="color: #a020f0;">if</span> (distance &gt; 0.d0) <span style="color: #a020f0;">then</span>
     potential = -1.d0 / distance
  <span style="color: #a020f0;">else</span>
     <span style="color: #a020f0;">stop</span> <span style="color: #8b2252;">'potential at r=0.d0 diverges'</span>
  <span style="color: #a020f0;">end if</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">potential</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org45f3e47" class="outline-4">
<h4 id="org45f3e47"><span class="section-number-4">2.1.2</span> Exercise 2</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="exercise">
<p>
Write a function which computes the wave function at \(\mathbf{r}\).
The function accepts a scalar <code>a</code> and a 3-dimensional vector <code>r</code> as
input arguments, and returns a scalar.
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">psi</span>(a, r):
    # <span style="color: #b22222;">TODO</span>
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">psi</span><span style="color: #000000; background-color: #ffffff;">(a, r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> a, r(3)</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">psi</span>
</pre>
</div>
</div>

<div id="outline-container-org17b1476" class="outline-5">
<h5 id="org17b1476"><span class="section-number-5">2.1.2.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-1-2-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">psi</span>(a, r):
    <span style="color: #a020f0;">return</span> np.exp(-a*np.sqrt(np.dot(r,r)))
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">psi</span><span style="color: #000000; background-color: #ffffff;">(a, r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> a, r(3)</span>

  psi = dexp(-a * dsqrt( r(1)*r(1) + r(2)*r(2) + r(3)*r(3) ))
<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">psi</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org41fbf18" class="outline-4">
<h4 id="org41fbf18"><span class="section-number-4">2.1.3</span> Exercise 3</h4>
<div class="outline-text-4" id="text-2-1-3">
<div class="exercise">
<p>
Write a function which computes the local kinetic energy at \(\mathbf{r}\).
The function accepts <code>a</code> and <code>r</code> as input arguments and returns the
local kinetic energy.
</p>

</div>

<p>
The local kinetic energy is defined as \[-\frac{1}{2}\frac{\Delta \Psi}{\Psi}.\]
</p>

<p>
We differentiate \(\Psi\) with respect to \(x\):
</p>

<p>
\[\Psi(\mathbf{r})  =  \exp(-a\,|\mathbf{r}|) \]
\[\frac{\partial \Psi}{\partial x}
      = \frac{\partial \Psi}{\partial |\mathbf{r}|} \frac{\partial |\mathbf{r}|}{\partial x}   
      =  - \frac{a\,x}{|\mathbf{r}|} \Psi(\mathbf{r}) \]
</p>

<p>
and we differentiate a second time:
</p>

<p>
\[
    \frac{\partial^2 \Psi}{\partial x^2} =
    \left( \frac{a^2\,x^2}{|\mathbf{r}|^2}  -
    \frac{a(y^2+z^2)}{|\mathbf{r}|^{3}} \right) \Psi(\mathbf{r}).
    \]
</p>

<p>
The Laplacian operator \(\Delta = \frac{\partial^2}{\partial x^2} +
    \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2}\)
applied to the wave function gives:
</p>

<p>
\[
    \Delta \Psi (\mathbf{r}) = \left(a^2 - \frac{2a}{\mathbf{|r|}} \right) \Psi(\mathbf{r})
    \]
</p>

<p>
So the local kinetic energy is
\[
    -\frac{1}{2} \frac{\Delta \Psi}{\Psi} (\mathbf{r}) = -\frac{1}{2}\left(a^2 - \frac{2a}{\mathbf{|r|}} \right) 
    \]
</p>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">kinetic</span>(a,r):
    # <span style="color: #b22222;">TODO</span>
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">kinetic</span><span style="color: #000000; background-color: #ffffff;">(a,r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> a, r(3)</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">kinetic</span>
</pre>
</div>
</div>

<div id="outline-container-org58a5a88" class="outline-5">
<h5 id="org58a5a88"><span class="section-number-5">2.1.3.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-1-3-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">kinetic</span>(a,r):
    <span style="color: #a0522d;">distance</span> = np.sqrt(np.dot(r,r))
    <span style="color: #a020f0;">assert</span> (distance &gt; 0.)

    <span style="color: #a020f0;">return</span> a * (1./distance - 0.5 * a)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">kinetic</span><span style="color: #000000; background-color: #ffffff;">(a,r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> a, r(3)</span>

  <span style="color: #228b22;">double precision</span>             ::<span style="color: #a0522d;"> distance</span>

  distance = dsqrt( r(1)*r(1) + r(2)*r(2) + r(3)*r(3) ) 

  <span style="color: #a020f0;">if</span> (distance &gt; 0.d0) <span style="color: #a020f0;">then</span>

     kinetic =  a * (1.d0 / distance - 0.5d0 * a)

  <span style="color: #a020f0;">else</span>
     <span style="color: #a020f0;">stop</span> <span style="color: #8b2252;">'kinetic energy diverges at r=0'</span>
  <span style="color: #a020f0;">end if</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">kinetic</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org19beacc" class="outline-4">
<h4 id="org19beacc"><span class="section-number-4">2.1.4</span> Exercise 4</h4>
<div class="outline-text-4" id="text-2-1-4">
<div class="exercise">
<p>
Write a function which computes the local energy at \(\mathbf{r}\),
using the previously defined functions.
The function accepts <code>a</code> and <code>r</code> as input arguments and returns the
local kinetic energy.
</p>

</div>

<p>
\[
    E_L(\mathbf{r}) = -\frac{1}{2} \frac{\Delta \Psi}{\Psi} (\mathbf{r}) + V(\mathbf{r})
    \]
</p>


<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">e_loc</span>(a,r):
    #<span style="color: #b22222;">TODO</span>
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">e_loc</span><span style="color: #000000; background-color: #ffffff;">(a,r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> a, r(3)</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">e_loc</span>
</pre>
</div>
</div>

<div id="outline-container-orgd059715" class="outline-5">
<h5 id="orgd059715"><span class="section-number-5">2.1.4.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-1-4-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">e_loc</span>(a,r):
    <span style="color: #a020f0;">return</span> kinetic(a,r) + potential(r)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #228b22;">double precision </span><span style="color: #a020f0;">function</span><span style="color: #a0522d;"> </span><span style="color: #0000ff;">e_loc</span><span style="color: #000000; background-color: #ffffff;">(a,r)</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> a, r(3)</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span>   ::<span style="color: #a0522d;"> kinetic, potential</span>

  e_loc = kinetic(a,r) + potential(r)

<span style="color: #a020f0;">end function</span> <span style="color: #0000ff;">e_loc</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfb98bee" class="outline-4">
<h4 id="orgfb98bee"><span class="section-number-4">2.1.5</span> Exercise 5</h4>
<div class="outline-text-4" id="text-2-1-5">
<div class="exercise">
<p>
Find the theoretical value of \(a\) for which \(\Psi\) is an eigenfunction of \(\hat{H}\).
</p>

</div>
</div>

<div id="outline-container-orgd271963" class="outline-5">
<h5 id="orgd271963"><span class="section-number-5">2.1.5.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-1-5-1">
\begin{eqnarray*}
E &=& \frac{\hat{H} \Psi}{\Psi} = - \frac{1}{2} \frac{\Delta \Psi}{\Psi} -
\frac{1}{|\mathbf{r}|}  \\
 &=& -\frac{1}{2}\left(a^2 - \frac{2a}{\mathbf{|r|}} \right) -
\frac{1}{|\mathbf{r}|} \\
 &=&
-\frac{1}{2} a^2 + \frac{a-1}{\mathbf{|r|}} 
\end{eqnarray*}

<p>
\(a=1\) cancels the \(1/|r|\) term, and makes the energy constant,
equal to -0.5 atomic units.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org6cc9505" class="outline-3">
<h3 id="org6cc9505"><span class="section-number-3">2.2</span> Plot of the local energy along the \(x\) axis</h3>
<div class="outline-text-3" id="text-2-2">
<div class="note">
<p>
The potential and the kinetic energy both diverge at \(r=0\), so we
choose a grid which does not contain the origin.
</p>

</div>
</div>

<div id="outline-container-org969c80e" class="outline-4">
<h4 id="org969c80e"><span class="section-number-4">2.2.1</span> Exercise</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="exercise">
<p>
For multiple values of \(a\) (0.1, 0.2, 0.5, 1., 1.5, 2.), plot the
local energy along the \(x\) axis. In Python, you can use matplotlib
for example. In Fortran, it is convenient to write in a text file
the values of \(x\) and \(E_L(\mathbf{r})\) for each point, and use
Gnuplot to plot the files.
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">import</span> matplotlib.pyplot <span style="color: #a020f0;">as</span> plt

<span style="color: #a020f0;">from</span> hydrogen <span style="color: #a020f0;">import</span> e_loc

<span style="color: #a0522d;">x</span>=np.linspace(-5,5)
plt.figure(figsize=(10,5))

# <span style="color: #b22222;">TODO</span>

plt.tight_layout()
plt.legend()
plt.savefig(<span style="color: #8b2252;">"plot_py.png"</span>)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">program</span> <span style="color: #0000ff;">plot</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> x(50), dx</span>
  <span style="color: #228b22;">integer</span> ::<span style="color: #a0522d;"> i, j</span>

  dx = 10.d0/(<span style="color: #a020f0;">size</span>(x)-1)
  <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
     x(i) = -5.d0 + (i-1)*dx
  <span style="color: #a020f0;">end do</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">plot</span>
</pre>
</div>

<p>
To compile and run:
</p>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 plot_hydrogen.f90 -o plot_hydrogen
./plot_hydrogen &gt; data
</pre>
</div>

<p>
To plot the data using Gnuplot:
</p>

<div class="org-src-container">
<pre class="src src-gnuplot">set grid
set xrange [-5:5]
set yrange [-2:1]
plot './data' index 0 using 1:2 with lines title 'a=0.1', \
     './data' index 1 using 1:2 with lines title 'a=0.2', \
     './data' index 2 using 1:2 with lines title 'a=0.5', \
     './data' index 3 using 1:2 with lines title 'a=1.0', \
     './data' index 4 using 1:2 with lines title 'a=1.5', \
     './data' index 5 using 1:2 with lines title 'a=2.0'
</pre>
</div>
</div>

<div id="outline-container-org1d42b6b" class="outline-5">
<h5 id="org1d42b6b"><span class="section-number-5">2.2.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-2-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">import</span> matplotlib.pyplot <span style="color: #a020f0;">as</span> plt

<span style="color: #a020f0;">from</span> hydrogen <span style="color: #a020f0;">import</span> e_loc

<span style="color: #a0522d;">x</span>=np.linspace(-5,5)
plt.figure(figsize=(10,5))

<span style="color: #a020f0;">for</span> a <span style="color: #a020f0;">in</span> [0.1, 0.2, 0.5, 1., 1.5, 2.]:
  <span style="color: #a0522d;">y</span>=np.array([ e_loc(a, np.array([t,0.,0.]) ) <span style="color: #a020f0;">for</span> t <span style="color: #a020f0;">in</span> x])
  plt.plot(x,y,label=f<span style="color: #8b2252;">"a={a}"</span>)

plt.tight_layout()
plt.legend()
plt.savefig(<span style="color: #8b2252;">"plot_py.png"</span>)
</pre>
</div>


<div class="figure">
<p><img src="./plot_py.png" alt="plot_py.png" />
</p>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">program</span> <span style="color: #0000ff;">plot</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> x(50), energy, dx, r(3), a(6)</span>
  <span style="color: #228b22;">integer</span> ::<span style="color: #a0522d;"> i, j</span>

  a = (/ 0.1d0, 0.2d0, 0.5d0, 1.d0, 1.5d0, 2.d0 /)

  dx = 10.d0/(<span style="color: #a020f0;">size</span>(x)-1)
  <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
     x(i) = -5.d0 + (i-1)*dx
  <span style="color: #a020f0;">end do</span>

  r(:) = 0.d0

  <span style="color: #a020f0;">do</span> j=1,<span style="color: #a020f0;">size</span>(a)
     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'# a='</span>, a(j)
     <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
        r(1) = x(i)
        energy = e_loc( a(j), r )
        <span style="color: #a020f0;">print</span> *, x(i), energy
     <span style="color: #a020f0;">end do</span>
     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">''</span>
     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">''</span>
  <span style="color: #a020f0;">end do</span>

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">plot</span>
</pre>
</div>


<div class="figure">
<p><img src="plot.png" alt="plot.png" />
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org4643440" class="outline-3">
<h3 id="org4643440"><span class="section-number-3">2.3</span> Numerical estimation of the energy</h3>
<div class="outline-text-3" id="text-2-3">
<p>
If the space is discretized in small volume elements \(\mathbf{r}_i\)
of size \(\delta \mathbf{r}\), the expression of \(\langle E_L \rangle_{\Psi^2}\)
becomes a weighted average of the local energy, where the weights
are the values of the probability density at \(\mathbf{r}_i\)
multiplied by the volume element:
</p>

<p>
\[
   \langle E \rangle_{\Psi^2} \approx \frac{\sum_i w_i E_L(\mathbf{r}_i)}{\sum_i w_i}, \;\;
   w_i = \left[\Psi(\mathbf{r}_i)\right]^2 \delta \mathbf{r}
   \]
</p>

<div class="note">
<p>
The energy is biased because:
</p>
<ul class="org-ul">
<li>The volume elements are not infinitely small (discretization error)</li>
<li>The energy is evaluated only inside the box (incompleteness of the space)</li>
</ul>

</div>
</div>


<div id="outline-container-org7934633" class="outline-4">
<h4 id="org7934633"><span class="section-number-4">2.3.1</span> Exercise</h4>
<div class="outline-text-4" id="text-2-3-1">
<div class="exercise">
<p>
Compute a numerical estimate of the energy in a grid of
\(50\times50\times50\) points in the range \((-5,-5,-5) \le
    \mathbf{r} \le (5,5,5)\).
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">from</span> hydrogen <span style="color: #a020f0;">import</span> e_loc, psi

<span style="color: #a0522d;">interval</span> = np.linspace(-5,5,num=50)
<span style="color: #a0522d;">delta</span> = (interval[1]-interval[0])**3

<span style="color: #a0522d;">r</span> = np.array([0.,0.,0.])

<span style="color: #a020f0;">for</span> a <span style="color: #a020f0;">in</span> [0.1, 0.2, 0.5, 0.9, 1., 1.5, 2.]:
    # <span style="color: #b22222;">TODO</span>
    <span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"a = {a} \t E = {E}"</span>)                

</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">program</span> <span style="color: #0000ff;">energy_hydrogen</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> x(50), w, delta, energy, dx, r(3), a(6), norm</span>
  <span style="color: #228b22;">integer</span> ::<span style="color: #a0522d;"> i, k, l, j</span>

  a = (/ 0.1d0, 0.2d0, 0.5d0, 1.d0, 1.5d0, 2.d0 /)

  dx = 10.d0/(<span style="color: #a020f0;">size</span>(x)-1)
  <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
     x(i) = -5.d0 + (i-1)*dx
  <span style="color: #a020f0;">end do</span>

  <span style="color: #a020f0;">do</span> j=1,<span style="color: #a020f0;">size</span>(a)

     ! <span style="color: #b22222;">TODO</span>

     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'a = '</span>, a(j), <span style="color: #8b2252;">'    E = '</span>, energy
  <span style="color: #a020f0;">end do</span>

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">energy_hydrogen</span>
</pre>
</div>

<p>
To compile the Fortran and run it:
</p>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 energy_hydrogen.f90 -o energy_hydrogen
./energy_hydrogen 
</pre>
</div>
</div>

<div id="outline-container-orgce31e40" class="outline-5">
<h5 id="orgce31e40"><span class="section-number-5">2.3.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-3-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">from</span> hydrogen <span style="color: #a020f0;">import</span> e_loc, psi

<span style="color: #a0522d;">interval</span> = np.linspace(-5,5,num=50)
<span style="color: #a0522d;">delta</span> = (interval[1]-interval[0])**3

<span style="color: #a0522d;">r</span> = np.array([0.,0.,0.])

<span style="color: #a020f0;">for</span> a <span style="color: #a020f0;">in</span> [0.1, 0.2, 0.5, 0.9, 1., 1.5, 2.]:
    <span style="color: #a0522d;">E</span>    = 0.
    <span style="color: #a0522d;">norm</span> = 0.

    <span style="color: #a020f0;">for</span> x <span style="color: #a020f0;">in</span> interval:
        <span style="color: #a0522d;">r</span>[0] = x
        <span style="color: #a020f0;">for</span> y <span style="color: #a020f0;">in</span> interval:
            <span style="color: #a0522d;">r</span>[1] = y
            <span style="color: #a020f0;">for</span> z <span style="color: #a020f0;">in</span> interval:
                <span style="color: #a0522d;">r</span>[2] = z

                <span style="color: #a0522d;">w</span> = psi(a,r)
                <span style="color: #a0522d;">w</span> = w * w * delta

                <span style="color: #a0522d;">E</span>    += w * e_loc(a,r)
                <span style="color: #a0522d;">norm</span> += w 

    <span style="color: #a0522d;">E</span> = E / norm
    <span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"a = {a} \t E = {E}"</span>)                

</pre>
</div>

<pre class="example">
a = 0.1 	 E = -0.24518438948809218
a = 0.2 	 E = -0.26966057967803525
a = 0.5 	 E = -0.3856357612517407
a = 0.9 	 E = -0.49435709786716214
a = 1.0 	 E = -0.5
a = 1.5 	 E = -0.39242967082602226
a = 2.0 	 E = -0.08086980667844901

</pre>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">program</span> <span style="color: #0000ff;">energy_hydrogen</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> x(50), w, delta, energy, dx, r(3), a(6), norm</span>
  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> i, k, l, j</span>

  a = (/ 0.1d0, 0.2d0, 0.5d0, 1.d0, 1.5d0, 2.d0 /)

  dx = 10.d0/(<span style="color: #a020f0;">size</span>(x)-1)
  <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
     x(i) = -5.d0 + (i-1)*dx
  <span style="color: #a020f0;">end do</span>

  delta = dx**3

  r(:) = 0.d0

  <span style="color: #a020f0;">do</span> j=1,<span style="color: #a020f0;">size</span>(a)
     energy = 0.d0
     norm   = 0.d0

     <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
        r(1) = x(i)

        <span style="color: #a020f0;">do</span> k=1,<span style="color: #a020f0;">size</span>(x)
           r(2) = x(k)

           <span style="color: #a020f0;">do</span> l=1,<span style="color: #a020f0;">size</span>(x)
              r(3) = x(l)

              w = psi(a(j),r)
              w = w * w * delta

              energy = energy + w * e_loc(a(j), r)
              norm   = norm   + w 
           <span style="color: #a020f0;">end do</span>

        <span style="color: #a020f0;">end do</span>

     <span style="color: #a020f0;">end do</span>

     energy = energy / norm
     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'a = '</span>, a(j), <span style="color: #8b2252;">'    E = '</span>, energy
  <span style="color: #a020f0;">end do</span>

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">energy_hydrogen</span>
</pre>
</div>

<pre class="example">
a =   0.10000000000000001          E =  -0.24518438948809140     
a =   0.20000000000000001          E =  -0.26966057967803236     
a =   0.50000000000000000          E =  -0.38563576125173815     
a =    1.0000000000000000          E =  -0.50000000000000000     
a =    1.5000000000000000          E =  -0.39242967082602065     
a =    2.0000000000000000          E =   -8.0869806678448772E-002

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org6c8b12d" class="outline-3">
<h3 id="org6c8b12d"><span class="section-number-3">2.4</span> Variance of the local energy</h3>
<div class="outline-text-3" id="text-2-4">
<p>
The variance of the local energy is a functional of \(\Psi\)
which measures the magnitude of the fluctuations of the local
energy associated with \(\Psi\) around its average:
</p>

<p>
\[
   \sigma^2(E_L) = \frac{\int \left[\Psi(\mathbf{r})\right]^2\, \left[
   E_L(\mathbf{r}) - E \right]^2 \, d\mathbf{r}}{\int \left[\Psi(\mathbf{r}) \right]^2 d\mathbf{r}}
   \]
which can be simplified as
</p>

<p>
\[ \sigma^2(E_L) = \langle E_L^2 \rangle_{\Psi^2} - \langle E_L \rangle_{\Psi^2}^2.\]
</p>

<p>
If the local energy is constant (i.e. \(\Psi\) is an eigenfunction of
\(\hat{H}\)) the variance is zero, so the variance of the local
energy can be used as a measure of the quality of a wave function.
</p>
</div>

<div id="outline-container-orgbb0a7be" class="outline-4">
<h4 id="orgbb0a7be"><span class="section-number-4">2.4.1</span> Exercise (optional)</h4>
<div class="outline-text-4" id="text-2-4-1">
<div class="exercise">
<p>
Prove that :
\[\left( \langle E - \langle E \rangle_{\Psi^2} \rangle_{\Psi^2} \right)^2 = \langle E^2 \rangle_{\Psi^2} - \langle E \rangle_{\Psi^2}^2 \]
</p>

</div>
</div>

<div id="outline-container-orgca7c679" class="outline-5">
<h5 id="orgca7c679"><span class="section-number-5">2.4.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-4-1-1">
<p>
\(\bar{E} = \langle E \rangle\) is a constant, so \(\langle \bar{E}
   \rangle = \bar{E}\) .
</p>

\begin{eqnarray*}
\langle E - \bar{E} \rangle^2 & = & 
\langle E^2 - 2 E \bar{E} + \bar{E}^2 \rangle \\
&=& \langle E^2 \rangle - 2 \langle E \bar{E} \rangle + \langle \bar{E}^2 \rangle \\
&=& \langle E^2 \rangle - 2 \langle E \rangle \bar{E}  + \bar{E}^2 \\
&=& \langle E^2 \rangle - 2 \bar{E}^2  + \bar{E}^2 \\
&=& \langle E^2 \rangle - \bar{E}^2 \\
&=& \langle E^2 \rangle - \langle E \rangle^2 \\
\end{eqnarray*}
</div>
</div>
</div>
<div id="outline-container-org696e18d" class="outline-4">
<h4 id="org696e18d"><span class="section-number-4">2.4.2</span> Exercise</h4>
<div class="outline-text-4" id="text-2-4-2">
<div class="exercise">
<p>
Add the calculation of the variance to the previous code, and
compute a numerical estimate of the variance of the local energy in
a grid of \(50\times50\times50\) points in the range \((-5,-5,-5) \le
   \mathbf{r} \le (5,5,5)\) for different values of \(a\).
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np <span style="color: #a020f0;">from</span> hydrogen <span style="color: #a020f0;">import</span> e_loc, psi

<span style="color: #a0522d;">interval</span> = np.linspace(-5,5,num=50)

<span style="color: #a0522d;">delta</span> = (interval[1]-interval[0])**3

<span style="color: #a0522d;">r</span> = np.array([0.,0.,0.])

<span style="color: #a020f0;">for</span> a <span style="color: #a020f0;">in</span> [0.1, 0.2, 0.5, 0.9, 1., 1.5, 2.]:

    # <span style="color: #b22222;">TODO</span>

    <span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"a = {a} \t E = {E:10.8f} \t \sigma^2 = {s2:10.8f}"</span>)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">program</span> <span style="color: #0000ff;">variance_hydrogen</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> x(50), w, delta, energy, energy2</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> dx, r(3), a(6), norm, e_tmp, s2</span>
  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> i, k, l, j</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  a = (/ 0.1d0, 0.2d0, 0.5d0, 1.d0, 1.5d0, 2.d0 /)

  dx = 10.d0/(<span style="color: #a020f0;">size</span>(x)-1)
  <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
     x(i) = -5.d0 + (i-1)*dx
  <span style="color: #a020f0;">end do</span>

  <span style="color: #a020f0;">do</span> j=1,<span style="color: #a020f0;">size</span>(a)

     ! <span style="color: #b22222;">TODO</span>

     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'a = '</span>, a(j), <span style="color: #8b2252;">'    E = '</span>, energy
  <span style="color: #a020f0;">end do</span>

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">variance_hydrogen</span>
</pre>
</div>

<p>
To compile and run:
</p>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 variance_hydrogen.f90 -o variance_hydrogen
./variance_hydrogen
</pre>
</div>
</div>

<div id="outline-container-orgee7fe6c" class="outline-5">
<h5 id="orgee7fe6c"><span class="section-number-5">2.4.2.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-2-4-2-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">import</span> numpy <span style="color: #a020f0;">as</span> np
<span style="color: #a020f0;">from</span> hydrogen <span style="color: #a020f0;">import</span> e_loc, psi

<span style="color: #a0522d;">interval</span> = np.linspace(-5,5,num=50)

<span style="color: #a0522d;">delta</span> = (interval[1]-interval[0])**3

<span style="color: #a0522d;">r</span> = np.array([0.,0.,0.])

<span style="color: #a020f0;">for</span> a <span style="color: #a020f0;">in</span> [0.1, 0.2, 0.5, 0.9, 1., 1.5, 2.]:
    <span style="color: #a0522d;">E</span>    = 0.
    <span style="color: #a0522d;">E2</span>   = 0.
    <span style="color: #a0522d;">norm</span> = 0.

    <span style="color: #a020f0;">for</span> x <span style="color: #a020f0;">in</span> interval:
        <span style="color: #a0522d;">r</span>[0] = x

        <span style="color: #a020f0;">for</span> y <span style="color: #a020f0;">in</span> interval:
            <span style="color: #a0522d;">r</span>[1] = y

            <span style="color: #a020f0;">for</span> z <span style="color: #a020f0;">in</span> interval:
                <span style="color: #a0522d;">r</span>[2] = z

                <span style="color: #a0522d;">w</span> = psi(a,r)
                <span style="color: #a0522d;">w</span> = w * w * delta

                <span style="color: #a0522d;">e_tmp</span> = e_loc(a,r)
                <span style="color: #a0522d;">E</span>    += w * e_tmp
                <span style="color: #a0522d;">E2</span>   += w * e_tmp * e_tmp
                <span style="color: #a0522d;">norm</span> += w 

    <span style="color: #a0522d;">E</span>  = E  / norm
    <span style="color: #a0522d;">E2</span> = E2 / norm

    <span style="color: #a0522d;">s2</span> = E2 - E**2
    <span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"a = {a} \t E = {E:10.8f} \t \sigma^2 = {s2:10.8f}"</span>)

</pre>
</div>

<pre class="example">
a = 0.1 	 E = -0.24518439 	 \sigma^2 = 0.02696522
a = 0.2 	 E = -0.26966058 	 \sigma^2 = 0.03719707
a = 0.5 	 E = -0.38563576 	 \sigma^2 = 0.05318597
a = 0.9 	 E = -0.49435710 	 \sigma^2 = 0.00577812
a = 1.0 	 E = -0.50000000 	 \sigma^2 = 0.00000000
a = 1.5 	 E = -0.39242967 	 \sigma^2 = 0.31449671
a = 2.0 	 E = -0.08086981 	 \sigma^2 = 1.80688143

</pre>

<p>
<b>Fortran</b>
</p>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">program</span> <span style="color: #0000ff;">variance_hydrogen</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> x(50), w, delta, energy, energy2</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> dx, r(3), a(6), norm, e_tmp, s2</span>
  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> i, k, l, j</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  a = (/ 0.1d0, 0.2d0, 0.5d0, 1.d0, 1.5d0, 2.d0 /)

  dx = 10.d0/(<span style="color: #a020f0;">size</span>(x)-1)
  <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
     x(i) = -5.d0 + (i-1)*dx
  <span style="color: #a020f0;">end do</span>

  delta = dx**3

  r(:) = 0.d0

  <span style="color: #a020f0;">do</span> j=1,<span style="color: #a020f0;">size</span>(a)
     energy  = 0.d0
     energy2 = 0.d0
     norm    = 0.d0

     <span style="color: #a020f0;">do</span> i=1,<span style="color: #a020f0;">size</span>(x)
        r(1) = x(i)

        <span style="color: #a020f0;">do</span> k=1,<span style="color: #a020f0;">size</span>(x)
           r(2) = x(k)

           <span style="color: #a020f0;">do</span> l=1,<span style="color: #a020f0;">size</span>(x)
              r(3) = x(l)

              w = psi(a(j),r)
              w = w * w * delta

              e_tmp = e_loc(a(j), r)

              energy  = energy  + w * e_tmp
              energy2 = energy2 + w * e_tmp * e_tmp
              norm   = norm     + w 
           <span style="color: #a020f0;">end do</span>

        <span style="color: #a020f0;">end do</span>

     <span style="color: #a020f0;">end do</span>

     energy  = energy  / norm
     energy2 = energy2 / norm

     s2 = energy2 - energy*energy

     <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'a = '</span>, a(j), <span style="color: #8b2252;">' E = '</span>, energy, <span style="color: #8b2252;">' s2 = '</span>, s2
  <span style="color: #a020f0;">end do</span>

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">variance_hydrogen</span>
</pre>
</div>

<pre class="example">
a =   0.10000000000000001      E =  -0.24518438948809140       s2 =    2.6965218719722767E-002
a =   0.20000000000000001      E =  -0.26966057967803236       s2 =    3.7197072370201284E-002
a =   0.50000000000000000      E =  -0.38563576125173815       s2 =    5.3185967578480653E-002
a =    1.0000000000000000      E =  -0.50000000000000000       s2 =    0.0000000000000000     
a =    1.5000000000000000      E =  -0.39242967082602065       s2 =   0.31449670909172917     
a =    2.0000000000000000      E =   -8.0869806678448772E-002  s2 =    1.8068814270846534     

</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6d5323b" class="outline-2">
<h2 id="org6d5323b"><span class="section-number-2">3</span> Variational Monte Carlo</h2>
<div class="outline-text-2" id="text-3">
<p>
Numerical integration with deterministic methods is very efficient
in low dimensions. When the number of dimensions becomes large,
instead of computing the average energy as a numerical integration
on a grid, it is usually more efficient to do a Monte Carlo sampling.
</p>

<p>
Moreover, a Monte Carlo sampling will alow us to remove the bias due
to the discretization of space, and compute a statistical confidence
interval.
</p>
</div>

<div id="outline-container-org945932a" class="outline-3">
<h3 id="org945932a"><span class="section-number-3">3.1</span> Computation of the statistical error</h3>
<div class="outline-text-3" id="text-3-1">
<p>
To compute the statistical error, you need to perform \(M\)
independent Monte Carlo calculations. You will obtain \(M\) different
estimates of the energy, which are expected to have a Gaussian
distribution according to the <a href="https://en.wikipedia.org/wiki/Central_limit_theorem">Central Limit Theorem</a>.
</p>

<p>
The estimate of the energy is
</p>

<p>
\[
   E = \frac{1}{M} \sum_{i=1}^M E_M
   \]
</p>

<p>
The variance of the average energies can be computed as
</p>

<p>
\[
   \sigma^2 = \frac{1}{M-1} \sum_{i=1}^{M} (E_M - E)^2
   \]
</p>

<p>
And the confidence interval is given by
</p>

<p>
\[
   E \pm \delta E, \text{ where } \delta E = \frac{\sigma}{\sqrt{M}}
   \]
</p>
</div>

<div id="outline-container-org7e965d1" class="outline-4">
<h4 id="org7e965d1"><span class="section-number-4">3.1.1</span> Exercise</h4>
<div class="outline-text-4" id="text-3-1-1">
<div class="exercise">
<p>
Write a function returning the average and statistical error of an
input array.
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> math <span style="color: #a020f0;">import</span> sqrt
<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">ave_error</span>(arr):
    #<span style="color: #b22222;">TODO</span>
    <span style="color: #a020f0;">return</span> (average, error)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">ave_error</span>(x,n,ave,err)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">integer</span>, <span style="color: #a020f0;">intent</span>(in)           ::<span style="color: #a0522d;"> n </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> x(n) </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> ave, err</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">ave_error</span>
</pre>
</div>
</div>

<div id="outline-container-org73d2a6e" class="outline-5">
<h5 id="org73d2a6e"><span class="section-number-5">3.1.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-3-1-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> math <span style="color: #a020f0;">import</span> sqrt
<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">ave_error</span>(arr):
    <span style="color: #a0522d;">M</span> = <span style="color: #483d8b;">len</span>(arr)
    <span style="color: #a020f0;">assert</span>(M&gt;0)

    <span style="color: #a020f0;">if</span> M == 1:
        <span style="color: #a0522d;">average</span> = arr[0]
        <span style="color: #a0522d;">error</span>   = 0.

    <span style="color: #a020f0;">else</span>:
        <span style="color: #a0522d;">average</span> = <span style="color: #483d8b;">sum</span>(arr)/M
        <span style="color: #a0522d;">variance</span> = 1./(M-1) * <span style="color: #483d8b;">sum</span>( [ (x - average)**2 <span style="color: #a020f0;">for</span> x <span style="color: #a020f0;">in</span> arr ] )
        <span style="color: #a0522d;">error</span> = sqrt(variance/M)

    <span style="color: #a020f0;">return</span> (average, error)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">ave_error</span>(x,n,ave,err)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>

  <span style="color: #228b22;">integer</span>, <span style="color: #a020f0;">intent</span>(in)           ::<span style="color: #a0522d;"> n </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> x(n) </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #228b22;">double precision</span>              ::<span style="color: #a0522d;"> variance</span>

  <span style="color: #a020f0;">if</span> (n &lt; 1) <span style="color: #a020f0;">then</span>
     <span style="color: #a020f0;">stop</span> <span style="color: #8b2252;">'n&lt;1 in ave_error'</span>

  <span style="color: #a020f0;">else if</span> (n == 1) <span style="color: #a020f0;">then</span>
     ave = x(1)
     err = 0.d0

  <span style="color: #a020f0;">else</span>
     ave      = <span style="color: #a020f0;">sum</span>(x(:)) / <span style="color: #a020f0;">dble</span>(n)

     variance = <span style="color: #a020f0;">sum</span>((x(:) - ave)**2) / <span style="color: #a020f0;">dble</span>(n-1)
     err      = dsqrt(variance/<span style="color: #a020f0;">dble</span>(n))

  <span style="color: #a020f0;">endif</span>
<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">ave_error</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org70d91fe" class="outline-3">
<h3 id="org70d91fe"><span class="section-number-3">3.2</span> Uniform sampling in the box</h3>
<div class="outline-text-3" id="text-3-2">
<p>
We will now do our first Monte Carlo calculation to compute the
energy of the hydrogen atom.
</p>

<p>
At every Monte Carlo iteration:
</p>

<ul class="org-ul">
<li>Draw a random point \(\mathbf{r}_i\) in the box \((-5,-5,-5) \le
     (x,y,z) \le (5,5,5)\)</li>
<li>Compute \([\Psi(\mathbf{r}_i)]^2\) and accumulate the result in a
variable <code>normalization</code></li>
<li>Compute \([\Psi(\mathbf{r}_i)]^2 \times E_L(\mathbf{r}_i)\), and accumulate the
result in a variable <code>energy</code></li>
</ul>

<p>
One Monte Carlo run will consist of \(N\) Monte Carlo iterations. Once all the
iterations have been computed, the run returns the average energy
\(\bar{E}_k\) over the \(N\) iterations of the run.
</p>

<p>
To compute the statistical error, perform \(M\) independent runs. The
final estimate of the energy will be the average over the
\(\bar{E}_k\), and the variance of the \(\bar{E}_k\) will be used to
compute the statistical error.
</p>
</div>

<div id="outline-container-org05579fd" class="outline-4">
<h4 id="org05579fd"><span class="section-number-4">3.2.1</span> Exercise</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="exercise">
<p>
Parameterize the wave function with \(a=0.9\).  Perform 30
independent Monte Carlo runs, each with 100 000 Monte Carlo
steps. Store the final energies of each run and use this array to
compute the average energy and the associated error bar.
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="note">
<p>
To draw a uniform random number in Python, you can use
the <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.uniform.html"><code>random.uniform</code></a> function of Numpy.
</p>

</div>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a, nmax):
     # <span style="color: #b22222;">TODO</span>

<span style="color: #a0522d;">a</span>    = 0.9
<span style="color: #a0522d;">nmax</span> = 100000

#<span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="note">
<p>
To draw a uniform random number in Fortran, you can use
the <a href="https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fNUMBER.html"><code>RANDOM_NUMBER</code></a> subroutine.
</p>

</div>

<div class="note">
<p>
When running Monte Carlo calculations, the number of steps is
usually very large. We expect <code>nmax</code> to be possibly larger than 2
billion, so we use 8-byte integers (<code>integer*8</code>) to represent it, as
well as the index of the current step.
</p>

</div>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">uniform_montecarlo</span>(a,nmax,energy)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> norm, r(3), w</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  ! <span style="color: #b22222;">TODO</span>
<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">uniform_montecarlo</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a = 0.9</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  !<span style="color: #b22222;">TODO</span>

  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 qmc_stats.f90 qmc_uniform.f90 -o qmc_uniform
./qmc_uniform
</pre>
</div>
</div>

<div id="outline-container-orgc64c471" class="outline-5">
<h5 id="orgc64c471"><span class="section-number-5">3.2.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-3-2-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a, nmax):
     <span style="color: #a0522d;">energy</span> = 0.
     <span style="color: #a0522d;">normalization</span> = 0.

     <span style="color: #a020f0;">for</span> istep <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(nmax):
          <span style="color: #a0522d;">r</span> = np.random.uniform(-5., 5., (3))

          <span style="color: #a0522d;">w</span> = psi(a,r)
          <span style="color: #a0522d;">w</span> = w*w

          <span style="color: #a0522d;">energy</span>        += w * e_loc(a,r)
          <span style="color: #a0522d;">normalization</span> += w

     <span style="color: #a020f0;">return</span> energy / normalization

<span style="color: #a0522d;">a</span>    = 0.9
<span style="color: #a0522d;">nmax</span> = 100000

<span style="color: #a0522d;">X</span> = [MonteCarlo(a,nmax) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)

<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)
</pre>
</div>

<pre class="example">
E = -0.4956255109300764 +/- 0.0007082875482711226

</pre>

<p>
<b>Fortran</b>
</p>
<div class="note">
<p>
When running Monte Carlo calculations, the number of steps is
usually very large. We expect <code>nmax</code> to be possibly larger than 2
billion, so we use 8-byte integers (<code>integer*8</code>) to represent it, as
well as the index of the current step.
</p>

</div>

<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">uniform_montecarlo</span>(a,nmax,energy)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> norm, r(3), w</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  energy = 0.d0
  norm   = 0.d0

  <span style="color: #a020f0;">do</span> istep = 1,nmax

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(r)
     r(:) = -5.d0 + 10.d0*r(:)

     w = psi(a,r)
     w = w*w

     energy = energy + w * e_loc(a,r)
     norm   = norm   + w

  <span style="color: #a020f0;">end do</span>

  energy = energy / norm

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">uniform_montecarlo</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a     = 0.9</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax  = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">uniform_montecarlo</span>(a, nmax, X(irun))
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X, nruns, ave, err)

  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err
<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<pre class="example">
E =  -0.49518773675598715      +/-   5.2391494923686175E-004

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga17395f" class="outline-3">
<h3 id="orga17395f"><span class="section-number-3">3.3</span> Metropolis sampling with \(\Psi^2\)</h3>
<div class="outline-text-3" id="text-3-3">
<p>
We will now use the square of the wave function to sample random
points distributed with the probability density
\[
   P(\mathbf{r}) = \left[\Psi(\mathbf{r})\right]^2
   \]
</p>

<p>
The expression of the average energy is now simplified as the average of
the local energies, since the weights are taken care of by the
sampling :
</p>

<p>
\[
   E \approx \frac{1}{M}\sum_{i=1}^M E_L(\mathbf{r}_i)
   \]
</p>


<p>
To sample a chosen probability density, an efficient method is the 
<a href="https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm">Metropolis-Hastings sampling algorithm</a>. Starting from a random
initial position \(\mathbf{r}_0\), we will realize a random walk as follows:
</p>

<p>
\[
   \mathbf{r}_{n+1} = \mathbf{r}_{n} + \delta t\, \mathbf{u}
   \]
</p>

<p>
where \(\delta t\) is a fixed constant (the so-called <i>time-step</i>), and
\(\mathbf{u}\) is a uniform random number in a 3-dimensional box
\((-1,-1,-1) \le \mathbf{u} \le (1,1,1)\). We will then add the
accept/reject step that guarantees that the distribution of the
\(\mathbf{r}_n\) is \(\Psi^2\):
</p>

<ol class="org-ol">
<li>Compute \(\Psi\) at a new position \(\mathbf{r'} = \mathbf{r}_n +
      \delta t\, \mathbf{u}\)</li>
<li>Compute the ratio \(R = \frac{\left[\Psi(\mathbf{r'})\right]^2}{\left[\Psi(\mathbf{r}_{n})\right]^2}\)</li>
<li>Draw a uniform random number \(v \in [0,1]\)</li>
<li>if \(v \le R\), accept the move : set \(\mathbf{r}_{n+1} = \mathbf{r'}\)</li>
<li>else, reject the move : set \(\mathbf{r}_{n+1} = \mathbf{r}_n\)</li>
<li>evaluate the local energy at \(\mathbf{r}_{n+1}\)</li>
</ol>

<div class="note">
<p>
A common error is to remove the rejected samples from the
calculation of the average. <b>Don't do it!</b>
</p>

<p>
All samples should be kept, from both accepted and rejected moves.
</p>

</div>

<p>
If the time step is infinitely small, the ratio will be very close
to one and all the steps will be accepted. But the trajectory will
be infinitely too short to have statistical significance.
</p>

<p>
On the other hand, as the time step increases, the number of
accepted steps will decrease because the ratios might become
small. If the number of accepted steps is close to zero, then the
space is not well sampled either.
</p>

<p>
The time step should be adjusted so that it is as large as
possible, keeping the number of accepted steps not too small. To
achieve that, we define the acceptance rate as the number of
accepted steps over the total number of steps. Adjusting the time
step such that the acceptance rate is close to 0.5 is a good compromise.
</p>
</div>


<div id="outline-container-org03d2480" class="outline-4">
<h4 id="org03d2480"><span class="section-number-4">3.3.1</span> Exercise</h4>
<div class="outline-text-4" id="text-3-3-1">
<div class="exercise">
<p>
Modify the program of the previous section to compute the energy,
sampled with \(\Psi^2\).
</p>

<p>
Compute also the acceptance rate, so that you can adapt the time
step in order to have an acceptance rate close to 0.5 .
</p>

<p>
Can you observe a reduction in the statistical error?
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a,nmax,dt):

    # <span style="color: #b22222;">TODO</span>

    <span style="color: #a020f0;">return</span> energy/nmax, N_accep/nmax


# <span style="color: #b22222;">Run simulation</span>
<span style="color: #a0522d;">a</span>    = 0.9
<span style="color: #a0522d;">nmax</span> = 100000
<span style="color: #a0522d;">dt</span>   = #<span style="color: #b22222;">TODO</span>

<span style="color: #a0522d;">X0</span> = [ MonteCarlo(a,nmax,dt) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]

# <span style="color: #b22222;">Energy</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (x, _) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)

# <span style="color: #b22222;">Acceptance rate</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (_, x) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">deltaA</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"A = {A} +/- {deltaA}"</span>)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">metropolis_montecarlo</span>(a,nmax,dt,energy,accep)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> dt </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> accep</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> n_accep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> r_old(3), r_new(3), psi_old, psi_new</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> v, ratio</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi, gaussian</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">metropolis_montecarlo</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a     = 0.9d0</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> dt    = </span>! <span style="color: #b22222;">TODO</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax  = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns), Y(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">metropolis_montecarlo</span>(a,nmax,dt,X(irun),Y(irun))
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(Y,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'A = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 qmc_stats.f90 qmc_metropolis.f90 -o qmc_metropolis
./qmc_metropolis
</pre>
</div>
</div>

<div id="outline-container-org277a0d2" class="outline-5">
<h5 id="org277a0d2"><span class="section-number-5">3.3.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-3-3-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a,nmax,dt):
    <span style="color: #a0522d;">energy</span>  = 0.
    <span style="color: #a0522d;">N_accep</span> = 0

    <span style="color: #a0522d;">r_old</span> = np.random.uniform(-dt, dt, (3))
    <span style="color: #a0522d;">psi_old</span> = psi(a,r_old)

    <span style="color: #a020f0;">for</span> istep <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(nmax):
        <span style="color: #a0522d;">energy</span> += e_loc(a,r_old)

        <span style="color: #a0522d;">r_new</span> = r_old + np.random.uniform(-dt,dt,(3))
        <span style="color: #a0522d;">psi_new</span> = psi(a,r_new)

        <span style="color: #a0522d;">ratio</span> = (psi_new / psi_old)**2

        <span style="color: #a020f0;">if</span> np.random.uniform() &lt;= ratio:
            <span style="color: #a0522d;">N_accep</span> += 1

            <span style="color: #a0522d;">r_old</span>   = r_new
            <span style="color: #a0522d;">psi_old</span> = psi_new

    <span style="color: #a020f0;">return</span> energy/nmax, N_accep/nmax

# <span style="color: #b22222;">Run simulation</span>
<span style="color: #a0522d;">a</span>    = 0.9
<span style="color: #a0522d;">nmax</span> = 100000
<span style="color: #a0522d;">dt</span>   = 1.3

<span style="color: #a0522d;">X0</span> = [ MonteCarlo(a,nmax,dt) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]

# <span style="color: #b22222;">Energy</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (x, _) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)

# <span style="color: #b22222;">Acceptance rate</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (_, x) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">deltaA</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"A = {A} +/- {deltaA}"</span>)
</pre>
</div>

<pre class="example">
E = -0.4950720838131573 +/- 0.00019089638602238043
A = 0.5172960000000001 +/- 0.0003443446549306529

</pre>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">metropolis_montecarlo</span>(a,nmax,dt,energy,accep)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> dt</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> accep</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> r_old(3), r_new(3), psi_old, psi_new</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> v, ratio</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> n_accep</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi, gaussian</span>

  energy  = 0.d0
  n_accep = 0_8

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(r_old)
  r_old(:) = dt * (2.d0*r_old(:) - 1.d0)
  psi_old = psi(a,r_old)

  <span style="color: #a020f0;">do</span> istep = 1,nmax
     energy = energy + e_loc(a,r_old)

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(r_new)
     r_new(:) = r_old(:) + dt*(2.d0*r_new(:) - 1.d0)

     psi_new = psi(a,r_new)

     ratio = (psi_new / psi_old)**2
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(v)

     <span style="color: #a020f0;">if</span> (v &lt;= ratio) <span style="color: #a020f0;">then</span>

        n_accep = n_accep + 1_8

        r_old(:) = r_new(:)
        psi_old = psi_new

     <span style="color: #a020f0;">endif</span>

  <span style="color: #a020f0;">end do</span>

  energy = energy / <span style="color: #a020f0;">dble</span>(nmax)
  accep  = <span style="color: #a020f0;">dble</span>(n_accep) / <span style="color: #a020f0;">dble</span>(nmax)

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">metropolis_montecarlo</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a = 0.9d0</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> dt = 1.3d0</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns), Y(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">metropolis_montecarlo</span>(a,nmax,dt,X(irun),Y(irun))
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(Y,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'A = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<pre class="example">
E =  -0.49503130891988767      +/-   1.7160104275040037E-004
A =   0.51695266666666673      +/-   4.0445505648997396E-004

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4b2e6bb" class="outline-3">
<h3 id="org4b2e6bb"><span class="section-number-3">3.4</span> Gaussian random number generator</h3>
<div class="outline-text-3" id="text-3-4">
<p>
To obtain Gaussian-distributed random numbers, you can apply the
<a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform">Box Muller transform</a> to uniform random numbers:
</p>

\begin{eqnarray*}
z_1 &=& \sqrt{-2 \ln u_1} \cos(2 \pi u_2) \\
z_2 &=& \sqrt{-2 \ln u_1} \sin(2 \pi u_2) 
\end{eqnarray*}

<p>
Below is a Fortran implementation returning a Gaussian-distributed
n-dimensional vector \(\mathbf{z}\). This will be useful for the
following sections.
</p>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">random_gauss</span>(z,n)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">integer</span>, <span style="color: #a020f0;">intent</span>(in) ::<span style="color: #a0522d;"> n</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> z(n)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> u(n+1)</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> two_pi = 2.d0*dacos(-1.d0)</span>
  <span style="color: #228b22;">integer</span> ::<span style="color: #a0522d;"> i</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(u)

  <span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">iand</span>(n,1) == 0) <span style="color: #a020f0;">then</span>
     ! <span style="color: #b22222;">n is even</span>
     <span style="color: #a020f0;">do</span> i=1,n,2
        z(i)   = dsqrt(-2.d0*dlog(u(i))) 
        z(i+1) = z(i) * dsin( two_pi*u(i+1) )
        z(i)   = z(i) * dcos( two_pi*u(i+1) )
     <span style="color: #a020f0;">end do</span>

  <span style="color: #a020f0;">else</span>
     ! <span style="color: #b22222;">n is odd</span>
     <span style="color: #a020f0;">do</span> i=1,n-1,2
        z(i)   = dsqrt(-2.d0*dlog(u(i))) 
        z(i+1) = z(i) * dsin( two_pi*u(i+1) )
        z(i)   = z(i) * dcos( two_pi*u(i+1) )
     <span style="color: #a020f0;">end do</span>

     z(n)   = dsqrt(-2.d0*dlog(u(n))) 
     z(n)   = z(n) * dcos( two_pi*u(n+1) )

  <span style="color: #a020f0;">end if</span>

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">random_gauss</span>
</pre>
</div>

<p>
In Python, you can use the <a href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.normal.html"><code>random.normal</code></a> function of Numpy.
</p>
</div>
</div>
<div id="outline-container-orgd704542" class="outline-3">
<h3 id="orgd704542"><span class="section-number-3">3.5</span> Generalized Metropolis algorithm</h3>
<div class="outline-text-3" id="text-3-5">
<p>
One can use more efficient numerical schemes to move the electrons,
but the Metropolis accepation step has to be adapted accordingly:
the acceptance
probability \(A\) is chosen so that it is consistent with the
probability of leaving \(\mathbf{r}_n\) and the probability of
entering \(\mathbf{r}_{n+1}\):
</p>

<p>
\[ A(\mathbf{r}_{n} \rightarrow \mathbf{r}_{n+1}) = \min \left( 1,
   \frac{T(\mathbf{r}_{n+1} \rightarrow \mathbf{r}_{n}) P(\mathbf{r}_{n+1})}
   {T(\mathbf{r}_{n} \rightarrow \mathbf{r}_{n+1}) P(\mathbf{r}_{n})}
   \right)
   \]
where \(T(\mathbf{r}_n \rightarrow \mathbf{r}_{n+1})\) is the
probability of transition from \(\mathbf{r}_n\) to
\(\mathbf{r}_{n+1}\).
</p>

<p>
In the previous example, we were using uniform random
numbers. Hence, the transition probability was
</p>

<p>
\[
   T(\mathbf{r}_{n} \rightarrow \mathbf{r}_{n+1})  = 
   \text{constant}
   \]
</p>

<p>
so the expression of \(A\) was simplified to the ratios of the squared
wave functions.
</p>

<p>
Now, if instead of drawing uniform random numbers we
choose to draw Gaussian random numbers with zero mean and variance
\(\delta t\), the transition probability becomes:
</p>

<p>
\[
   T(\mathbf{r}_{n} \rightarrow \mathbf{r}_{n+1})  = 
   \frac{1}{(2\pi\,\delta t)^{3/2}} \exp \left[ - \frac{\left(
   \mathbf{r}_{n+1} - \mathbf{r}_{n} \right)^2}{2\delta t} \right]
   \]
</p>


<p>
To sample even better the density, we can "push" the electrons
into in the regions of high probability, and "pull" them away from
the low-probability regions. This will mechanically increase the
acceptance ratios and improve the sampling.
</p>

<p>
To do this, we can add the drift vector
</p>

<p>
\[
   \frac{\nabla [ \Psi^2 ]}{\Psi^2} = 2 \frac{\nabla \Psi}{\Psi}.
   \]
</p>

<p>
The numerical scheme becomes a drifted diffusion:
</p>

<p>
\[
   \mathbf{r}_{n+1} = \mathbf{r}_{n} + \delta t\, \frac{\nabla
   \Psi(\mathbf{r})}{\Psi(\mathbf{r})} + \chi 
   \]
</p>

<p>
where \(\chi\) is a Gaussian random variable with zero mean and
variance \(\delta t\).
The transition probability becomes:
</p>

<p>
\[
   T(\mathbf{r}_{n} \rightarrow \mathbf{r}_{n+1})  = 
   \frac{1}{(2\pi\,\delta t)^{3/2}} \exp \left[ - \frac{\left(
   \mathbf{r}_{n+1} - \mathbf{r}_{n} - \frac{\nabla
   \Psi(\mathbf{r}_n)}{\Psi(\mathbf{r}_n)} \right)^2}{2\,\delta t} \right]
   \]
</p>
</div>


<div id="outline-container-org107b8c2" class="outline-4">
<h4 id="org107b8c2"><span class="section-number-4">3.5.1</span> Exercise 1</h4>
<div class="outline-text-4" id="text-3-5-1">
<div class="exercise">
<p>
Write a function to compute the drift vector \(\frac{\nabla \Psi(\mathbf{r})}{\Psi(\mathbf{r})}\).
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">drift</span>(a,r):
   # <span style="color: #b22222;">TODO</span>
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">drift</span>(a,r,b)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a, r(3)</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> b(3)</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">drift</span>
</pre>
</div>
</div>

<div id="outline-container-org8b8a874" class="outline-5">
<h5 id="org8b8a874"><span class="section-number-5">3.5.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-3-5-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">drift</span>(a,r):
   <span style="color: #a0522d;">ar_inv</span> = -a/np.sqrt(np.dot(r,r))
   <span style="color: #a020f0;">return</span> r * ar_inv
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">drift</span>(a,r,b)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a, r(3)</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> b(3)</span>

  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ar_inv</span>

  ar_inv = -a / dsqrt(r(1)*r(1) + r(2)*r(2) + r(3)*r(3))
  b(:)   = r(:) * ar_inv

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">drift</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org02c9606" class="outline-4">
<h4 id="org02c9606"><span class="section-number-4">3.5.2</span> Exercise 2</h4>
<div class="outline-text-4" id="text-3-5-2">
<div class="exercise">
<p>
Modify the previous program to introduce the drifted diffusion scheme.
(This is a necessary step for the next section).
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a,nmax,dt):
   # <span style="color: #b22222;">TODO</span>

# <span style="color: #b22222;">Run simulation</span>
<span style="color: #a0522d;">a</span>    = 0.9
<span style="color: #a0522d;">nmax</span> = 100000
<span style="color: #a0522d;">dt</span>   = # <span style="color: #b22222;">TODO</span>

<span style="color: #a0522d;">X0</span> = [ MonteCarlo(a,nmax,dt) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]

# <span style="color: #b22222;">Energy</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (x, _) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)

# <span style="color: #b22222;">Acceptance rate</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (_, x) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">deltaA</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"A = {A} +/- {deltaA}"</span>)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">variational_montecarlo</span>(a,dt,nmax,energy,accep)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a, dt</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy, accep</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> n_accep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> sq_dt, chi(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> psi_old, psi_new</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> r_old(3), r_new(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> d_old(3), d_new(3)</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">variational_montecarlo</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a     = 0.9</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> dt    = </span>! <span style="color: #b22222;">TODO</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax  = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns), accep(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">variational_montecarlo</span>(a,dt,nmax,X(irun),accep(irun))
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(accep,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'A = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 qmc_stats.f90 vmc_metropolis.f90 -o vmc_metropolis
./vmc_metropolis
</pre>
</div>
</div>

<div id="outline-container-org4580e2f" class="outline-5">
<h5 id="org4580e2f"><span class="section-number-5">3.5.2.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-3-5-2-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a,nmax,dt):
    <span style="color: #a0522d;">sq_dt</span> = np.sqrt(dt)

    <span style="color: #a0522d;">energy</span>  = 0.
    <span style="color: #a0522d;">N_accep</span> = 0

    <span style="color: #a0522d;">r_old</span>   = np.random.normal(loc=0., scale=1.0, size=(3))
    <span style="color: #a0522d;">d_old</span>   = drift(a,r_old)
    <span style="color: #a0522d;">d2_old</span>  = np.dot(d_old,d_old)
    <span style="color: #a0522d;">psi_old</span> = psi(a,r_old)

    <span style="color: #a020f0;">for</span> istep <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(nmax):
        <span style="color: #a0522d;">chi</span> = np.random.normal(loc=0., scale=1.0, size=(3))

        <span style="color: #a0522d;">energy</span> += e_loc(a,r_old)

        <span style="color: #a0522d;">r_new</span>   = r_old + dt * d_old + sq_dt * chi
        <span style="color: #a0522d;">d_new</span>   = drift(a,r_new)
        <span style="color: #a0522d;">d2_new</span>  = np.dot(d_new,d_new)
        <span style="color: #a0522d;">psi_new</span> = psi(a,r_new)

        # <span style="color: #b22222;">Metropolis</span>
        <span style="color: #a0522d;">prod</span>    = np.dot((d_new + d_old), (r_new - r_old))
        <span style="color: #a0522d;">argexpo</span> = 0.5 * (d2_new - d2_old)*dt + prod

        <span style="color: #a0522d;">q</span> = psi_new / psi_old
        <span style="color: #a0522d;">q</span> = np.exp(-argexpo) * q*q

        <span style="color: #a020f0;">if</span> np.random.uniform() &lt;= q:
            <span style="color: #a0522d;">N_accep</span> += 1

            <span style="color: #a0522d;">r_old</span>   = r_new
            <span style="color: #a0522d;">d_old</span>   = d_new
            <span style="color: #a0522d;">d2_old</span>  = d2_new
            <span style="color: #a0522d;">psi_old</span> = psi_new

    <span style="color: #a020f0;">return</span> energy/nmax, accep_rate/nmax


# <span style="color: #b22222;">Run simulation</span>
<span style="color: #a0522d;">a</span>    = 0.9
<span style="color: #a0522d;">nmax</span> = 100000
<span style="color: #a0522d;">dt</span>   = 1.3

<span style="color: #a0522d;">X0</span> = [ MonteCarlo(a,nmax,dt) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]

# <span style="color: #b22222;">Energy</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (x, _) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)

# <span style="color: #b22222;">Acceptance rate</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (_, x) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">deltaA</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"A = {A} +/- {deltaA}"</span>)
</pre>
</div>

<pre class="example">
E = -0.4951317910667116 +/- 0.00014045774335059988
A = 0.7200673333333333 +/- 0.00045942791345632793

</pre>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">variational_montecarlo</span>(a,dt,nmax,energy,accep)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a, dt</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy, accep</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> n_accep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> sq_dt, chi(3), d2_old, prod, u</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> psi_old, psi_new, d2_new, argexpo, q</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> r_old(3), r_new(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> d_old(3), d_new(3)</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  sq_dt = dsqrt(dt)

  ! <span style="color: #b22222;">Initialization</span>
  energy  = 0.d0
  n_accep = 0_8

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_gauss</span>(r_old,3)

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">drift</span>(a,r_old,d_old)
  d2_old  = d_old(1)*d_old(1) + <span style="color: #a020f0;">&amp;</span>
            d_old(2)*d_old(2) + <span style="color: #a020f0;">&amp;</span>
            d_old(3)*d_old(3)

  psi_old = psi(a,r_old)

  <span style="color: #a020f0;">do</span> istep = 1,nmax
     energy = energy + e_loc(a,r_old)

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_gauss</span>(chi,3)
     r_new(:) = r_old(:) + dt*d_old(:) + chi(:)*sq_dt

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">drift</span>(a,r_new,d_new)
     d2_new = d_new(1)*d_new(1) + <span style="color: #a020f0;">&amp;</span>
              d_new(2)*d_new(2) + <span style="color: #a020f0;">&amp;</span>
              d_new(3)*d_new(3)

     psi_new = psi(a,r_new)

     ! <span style="color: #b22222;">Metropolis</span>
     prod = (d_new(1) + d_old(1))*(r_new(1) - r_old(1)) + <span style="color: #a020f0;">&amp;</span>
            (d_new(2) + d_old(2))*(r_new(2) - r_old(2)) + <span style="color: #a020f0;">&amp;</span>
            (d_new(3) + d_old(3))*(r_new(3) - r_old(3))

     argexpo = 0.5d0 * (d2_new - d2_old)*dt + prod

     q = psi_new / psi_old
     q = dexp(-argexpo) * q*q

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(u)

     <span style="color: #a020f0;">if</span> (u &lt;= q) <span style="color: #a020f0;">then</span>

        n_accep = n_accep + 1_8

        r_old(:) = r_new(:)
        d_old(:) = d_new(:)
        d2_old   = d2_new
        psi_old  = psi_new

     <span style="color: #a020f0;">end if</span>

  <span style="color: #a020f0;">end do</span>

  energy = energy / <span style="color: #a020f0;">dble</span>(nmax)
  accep  = <span style="color: #a020f0;">dble</span>(n_accep) / <span style="color: #a020f0;">dble</span>(nmax)

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">variational_montecarlo</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a     = 0.9</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> dt    = 1.0</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax  = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns), accep(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">variational_montecarlo</span>(a,dt,nmax,X(irun),accep(irun))
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(accep,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'A = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<pre class="example">
E =  -0.49497258331144794      +/-   1.0973395750688713E-004
A =   0.78839866666666658      +/-   3.2503783452043152E-004

</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgdceacd5" class="outline-2">
<h2 id="orgdceacd5"><span class="section-number-2">4</span> Diffusion Monte Carlo&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org3941aac" class="outline-3">
<h3 id="org3941aac"><span class="section-number-3">4.1</span> Schrödinger equation in imaginary time</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Consider the time-dependent Schrödinger equation:
</p>

<p>
\[
    i\frac{\partial \Psi(\mathbf{r},t)}{\partial t} = \hat{H} \Psi(\mathbf{r},t) 
    \]
</p>

<p>
We can expand \(\Psi(\mathbf{r},0)\), in the basis of the eigenstates
of the time-independent Hamiltonian:
</p>

<p>
\[
    \Psi(\mathbf{r},0) = \sum_k a_k\, \Phi_k(\mathbf{r}).
    \]
</p>

<p>
The solution of the Schrödinger equation at time \(t\) is 
</p>

<p>
\[
    \Psi(\mathbf{r},t) = \sum_k a_k \exp \left( -i\, E_k\, t \right) \Phi_k(\mathbf{r}).
    \]
</p>

<p>
Now, let's replace the time variable \(t\) by an imaginary time variable
\(\tau=i\,t\), we obtain
</p>

<p>
\[
    -\frac{\partial \psi(\mathbf{r}, \tau)}{\partial \tau} = \hat{H} \psi(\mathbf{r}, \tau) 
    \]
</p>

<p>
where \(\psi(\mathbf{r},\tau) = \Psi(\mathbf{r},-i\tau) = \Psi(\mathbf{r},t)\)
and
\[
   \psi(\mathbf{r},\tau) = \sum_k a_k \exp( -E_k\, \tau) \phi_k(\mathbf{r}).
    \]
For large positive values of \(\tau\), \(\psi\) is dominated by the
\(k=0\) term, namely the lowest eigenstate.
So we can expect that simulating the differetial equation in
imaginary time will converge to the exact ground state of the
system.
</p>
</div>
</div>

<div id="outline-container-orge021b97" class="outline-3">
<h3 id="orge021b97"><span class="section-number-3">4.2</span> Diffusion and branching</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The <a href="https://en.wikipedia.org/wiki/Diffusion_equation">diffusion equation</a> of particles is given by
</p>

<p>
\[
    \frac{\partial \phi(\mathbf{r},t)}{\partial t} = D\, \Delta \phi(\mathbf{r},t).
    \]
</p>

<p>
The <a href="https://en.wikipedia.org/wiki/Reaction_rate">rate of reaction</a> \(v\) is the speed at which a chemical reaction
takes place. In a solution, the rate is given as a function of the
concentration \([A]\) by
</p>

<p>
\[
    v = \frac{d[A]}{dt},
    \]
</p>

<p>
where the concentration \([A]\) is proportional to the number of particles.
</p>

<p>
These two equations allow us to interpret the Schrödinger equation
in imaginary time as the combination of:
</p>
<ul class="org-ul">
<li>a diffusion equation with a diffusion coefficient \(D=1/2\) for the
kinetic energy, and</li>
<li>a rate equation for the potential.</li>
</ul>

<p>
The diffusion equation can be simulated by a Brownian motion:
\[ \mathbf{r}_{n+1} = \mathbf{r}_{n} + \sqrt{\delta t}\, \chi \]
where \(\chi\) is a Gaussian random variable, and the rate equation
can be simulated by creating or destroying particles over time (a
so-called branching process).
</p>

<p>
<i>Diffusion Monte Carlo</i> (DMC) consists in obtaining the ground state of a
system by simulating the Schrödinger equation in imaginary time, by
the combination of a diffusion process and a branching process. 
</p>
</div>
</div>

<div id="outline-container-org0d37b59" class="outline-3">
<h3 id="org0d37b59"><span class="section-number-3">4.3</span> Importance sampling</h3>
<div class="outline-text-3" id="text-4-3">
<p>
In a molecular system, the potential is far from being constant,
and diverges at inter-particle coalescence points. Hence, when the
rate equation is simulated, it results in very large fluctuations
in the numbers of particles, making the calculations impossible in
practice.
Fortunately, if we multiply the Schrödinger equation by a chosen
<i>trial wave function</i> \(\Psi_T(\mathbf{r})\) (Hartree-Fock, Kohn-Sham
determinant, CI wave function, <i>etc</i>), one obtains
</p>

<p>
\[
    -\frac{\partial \psi(\mathbf{r},\tau)}{\partial \tau} \Psi_T(\mathbf{r}) =
    \left[ -\frac{1}{2} \Delta \psi(\mathbf{r},\tau) + V(\mathbf{r}) \psi(\mathbf{r},\tau) \right] \Psi_T(\mathbf{r}) 
  \]
</p>

<p>
Defining \(\Pi(\mathbf{r},\tau) = \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r})\), (see appendix for details)
</p>

<p>
\[
  -\frac{\partial \Pi(\mathbf{r},\tau)}{\partial \tau}
  = -\frac{1}{2} \Delta \Pi(\mathbf{r},\tau) +
  \nabla \left[ \Pi(\mathbf{r},\tau) \frac{\nabla \Psi_T(\mathbf{r})}{\Psi_T(\mathbf{r})}
  \right] + E_L(\mathbf{r}) \Pi(\mathbf{r},\tau) 
  \]
</p>

<p>
The new "kinetic energy" can be simulated by the drifted diffusion
scheme presented in the previous section (VMC).
The new "potential" is the local energy, which has smaller fluctuations
when \(\Psi_T\) gets closer to the exact wave function. It can be simulated by
changing the number of particles according to \(\exp\left[ -\delta t\,
  \left(E_L(\mathbf{r}) - E_\text{ref}\right)\right]\)
where \(E_{\text{ref}}\) is a constant introduced so that the average
of this term is close to one, keeping the number of particles rather
constant.
</p>

<p>
This equation generates the <i>N</i>-electron density \(\Pi\), which is the
product of the ground state with the trial wave function. It
introduces the constraint that \(\Pi(\mathbf{r},\tau)=0\) where
\(\Psi_T(\mathbf{r})=0\). In the few cases where the wave function has no nodes,
such as in the hydrogen atom or the H<sub>2</sub> molecule, this
constraint is harmless and we can obtain the exact energy. But for
systems where the wave function has nodes, this scheme introduces an
error known as the <i>fixed node error</i>.
</p>
</div>

<div id="outline-container-orgc0fb19f" class="outline-4">
<h4 id="orgc0fb19f"><span class="section-number-4">4.3.1</span> Appendix : Details of the Derivation</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
\[
    -\frac{\partial \psi(\mathbf{r},\tau)}{\partial \tau} \Psi_T(\mathbf{r}) =
    \left[ -\frac{1}{2} \Delta \psi(\mathbf{r},\tau) + V(\mathbf{r}) \psi(\mathbf{r},\tau) \right] \Psi_T(\mathbf{r}) 
  \]
</p>

<p>
\[
  -\frac{\partial \big[ \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big]}{\partial \tau}
  = -\frac{1}{2} \Big( \Delta \big[
  \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big] -
  \psi(\mathbf{r},\tau) \Delta \Psi_T(\mathbf{r}) - 2
  \nabla \psi(\mathbf{r},\tau) \nabla \Psi_T(\mathbf{r}) \Big) + V(\mathbf{r}) \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) 
  \]
</p>

<p>
\[
  -\frac{\partial \big[ \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big]}{\partial \tau}
  = -\frac{1}{2} \Delta \big[\psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big] +
     \frac{1}{2} \psi(\mathbf{r},\tau) \Delta \Psi_T(\mathbf{r}) + 
  \Psi_T(\mathbf{r})\nabla \psi(\mathbf{r},\tau) \frac{\nabla \Psi_T(\mathbf{r})}{\Psi_T(\mathbf{r})} + V(\mathbf{r}) \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) 
  \]
</p>

<p>
\[
  -\frac{\partial \big[ \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big]}{\partial \tau}
  = -\frac{1}{2} \Delta \big[\psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big] +
                 \psi(\mathbf{r},\tau) \Delta \Psi_T(\mathbf{r}) + 
  \Psi_T(\mathbf{r})\nabla \psi(\mathbf{r},\tau) \frac{\nabla \Psi_T(\mathbf{r})}{\Psi_T(\mathbf{r})} + E_L(\mathbf{r}) \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) 
  \]
\[
  -\frac{\partial \big[ \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big]}{\partial \tau}
  = -\frac{1}{2} \Delta \big[\psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) \big] +
  \nabla \left[ \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r})
  \frac{\nabla \Psi_T(\mathbf{r})}{\Psi_T(\mathbf{r})}
  \right] + E_L(\mathbf{r}) \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) 
  \]
</p>

<p>
Defining \(\Pi(\mathbf{r},t) = \psi(\mathbf{r},\tau)
  \Psi_T(\mathbf{r})\), 
</p>

<p>
\[
  -\frac{\partial \Pi(\mathbf{r},\tau)}{\partial \tau}
  = -\frac{1}{2} \Delta \Pi(\mathbf{r},\tau) +
  \nabla \left[ \Pi(\mathbf{r},\tau) \frac{\nabla \Psi_T(\mathbf{r})}{\Psi_T(\mathbf{r})}
  \right] + E_L(\mathbf{r}) \Pi(\mathbf{r},\tau) 
  \]
</p>
</div>
</div>
</div>


<div id="outline-container-orgb90c671" class="outline-3">
<h3 id="orgb90c671"><span class="section-number-3">4.4</span> Fixed-node DMC energy</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Now that we have a process to sample \(\Pi(\mathbf{r},\tau) =
   \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r})\), we can compute the exact
energy of the system, within the fixed-node constraint, as:
</p>

<p>
\[
   E = \lim_{\tau \to \infty} \frac{\int \Pi(\mathbf{r},\tau) E_L(\mathbf{r}) d\mathbf{r}}
            {\int \Pi(\mathbf{r},\tau) d\mathbf{r}} = \lim_{\tau \to
   \infty} E(\tau).
   \]
</p>


<p>
\[
   E(\tau)   =   \frac{\int \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) E_L(\mathbf{r}) d\mathbf{r}}
                {\int \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) d\mathbf{r}} 
       =   \frac{\int \psi(\mathbf{r},\tau) \hat{H} \Psi_T(\mathbf{r}) d\mathbf{r}}
                {\int \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) d\mathbf{r}} 
       =   \frac{\langle \psi_\tau | \hat{H} | \Psi_T \rangle}
                {\langle  \psi_\tau | \Psi_T \rangle} 
   \]
</p>

<p>
As \(\hat{H}\) is Hermitian, 
</p>

<p>
\[
   E(\tau) = \frac{\langle \psi_\tau | \hat{H} | \Psi_T \rangle}
            {\langle  \psi_\tau | \Psi_T \rangle}  
     = \frac{\langle \Psi_T | \hat{H} | \psi_\tau \rangle}
            {\langle  \Psi_T | \psi_\tau \rangle}  
     = E[\psi_\tau] \frac{\langle  \Psi_T | \psi_\tau \rangle}  
            {\langle  \Psi_T | \psi_\tau \rangle} 
     = E[\psi_\tau] 
   \]
</p>

<p>
So computing the energy within DMC consists in generating the
density \(\Pi\) with random walks, and simply averaging the local
energies computed with the trial wave function.
</p>
</div>
</div>

<div id="outline-container-org971d2c0" class="outline-3">
<h3 id="org971d2c0"><span class="section-number-3">4.5</span> Pure Diffusion Monte Carlo (PDMC)</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Instead of having a variable number of particles to simulate the
branching process, one can choose to sample \([\Psi_T(\mathbf{r})]^2\) instead of
\(\psi(\mathbf{r},\tau) \Psi_T(\mathbf{r})\), and consider the term
\(\exp \left( -\delta t\,(  E_L(\mathbf{r}) - E_{\text{ref}}  \right)\) as a
cumulative product of weights:
</p>

<p>
\[
   W(\mathbf{r}_n, \tau)
   = \exp \left( \int_0^\tau - (E_L(\mathbf{r}_t) - E_{\text{ref}}) dt \right)
   \approx \prod_{i=1}^{n} \exp \left( -\delta t\,
   (E_L(\mathbf{r}_i) - E_{\text{ref}}) \right) = 
   \prod_{i=1}^{n} w(\mathbf{r}_i)
   \]
</p>

<p>
where \(\mathbf{r}_i\) are the coordinates along the trajectory.
The wave function becomes
</p>

<p>
\[
   \psi(\mathbf{r},\tau) = \Psi_T(\mathbf{r}) W(\mathbf{r},\tau)
   \]
</p>

<p>
and the expression of the fixed-node DMC energy is
</p>

\begin{eqnarray*}
E(\tau) & = & \frac{\int \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) E_L(\mathbf{r}) d\mathbf{r}}
                   {\int \psi(\mathbf{r},\tau) \Psi_T(\mathbf{r}) d\mathbf{r}} \\
        & = & \frac{\int \left[ \Psi_T(\mathbf{r}) \right]^2 W(\mathbf{r},\tau) E_L(\mathbf{r}) d\mathbf{r}}
                   {\int \left[ \Psi_T(\mathbf{r}) \right]^2 W(\mathbf{r},\tau) d\mathbf{r}} \\
\end{eqnarray*}

<p>
This algorithm is less stable than the branching algorithm: it 
requires to have a value of \(E_\text{ref}\) which is close to the
fixed-node energy, and a good trial wave function. Its big
advantage is that it is very easy to program starting from a VMC
code, so this is what we will do in the next section.
</p>
</div>
</div>

<div id="outline-container-orgf89d780" class="outline-3">
<h3 id="orgf89d780"><span class="section-number-3">4.6</span> Hydrogen atom</h3>
<div class="outline-text-3" id="text-4-6">
</div>

<div id="outline-container-orga1bc199" class="outline-4">
<h4 id="orga1bc199"><span class="section-number-4">4.6.1</span> Exercise</h4>
<div class="outline-text-4" id="text-4-6-1">
<div class="exercise">
<p>
Modify the Metropolis VMC program to introduce the PDMC weight.
In the limit \(\delta t \rightarrow 0\), you should recover the exact
energy of H for any value of \(a\).
</p>

</div>

<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a, nmax, dt, Eref):
    # <span style="color: #b22222;">TODO</span>

# <span style="color: #b22222;">Run simulation</span>
<span style="color: #a0522d;">a</span>     = 0.9
<span style="color: #a0522d;">nmax</span>  = 100000
<span style="color: #a0522d;">dt</span>    = 0.01
<span style="color: #a0522d;">E_ref</span> = -0.5

<span style="color: #a0522d;">X0</span> = [ MonteCarlo(a, nmax, dt, E_ref) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]

# <span style="color: #b22222;">Energy</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (x, _) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)

# <span style="color: #b22222;">Acceptance rate</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (_, x) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">deltaA</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"A = {A} +/- {deltaA}"</span>)
</pre>
</div>

<p>
<b>Fortran</b>
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">pdmc</span>(a, dt, nmax, energy, accep, tau, E_ref)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a, dt, tau</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy, accep</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> E_ref</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> n_accep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> sq_dt, chi(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> psi_old, psi_new</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> r_old(3), r_new(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> d_old(3), d_new(3)</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  ! <span style="color: #b22222;">TODO</span>

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">pdmc</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a     = 0.9</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> dt    = 0.1d0</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> E_ref = -0.5d0</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> tau   = 10.d0</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax  = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns), accep(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">pdmc</span>(a, dt, nmax, X(irun), accep(irun), tau, E_ref)
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(accep,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'A = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">gfortran hydrogen.f90 qmc_stats.f90 pdmc.f90 -o pdmc
./pdmc
</pre>
</div>
</div>

<div id="outline-container-orga0bccd7" class="outline-5">
<h5 id="orga0bccd7"><span class="section-number-5">4.6.1.1</span> Solution&#xa0;&#xa0;&#xa0;<span class="tag"><span class="solution">solution</span></span></h5>
<div class="outline-text-5" id="text-4-6-1-1">
<p>
<b>Python</b>
</p>
<div class="org-src-container">
<pre class="src src-python"><span style="color: #a020f0;">from</span> hydrogen  <span style="color: #a020f0;">import</span> *
<span style="color: #a020f0;">from</span> qmc_stats <span style="color: #a020f0;">import</span> *

<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">MonteCarlo</span>(a, nmax, dt, tau, Eref):
    <span style="color: #a0522d;">sq_dt</span> = np.sqrt(dt)

    <span style="color: #a0522d;">energy</span>        = 0.
    <span style="color: #a0522d;">N_accep</span>       = 0
    <span style="color: #a0522d;">normalization</span> = 0.

    <span style="color: #a0522d;">w</span> = 1.
    <span style="color: #a0522d;">tau_current</span> = 0.

    <span style="color: #a0522d;">r_old</span>   = np.random.normal(loc=0., scale=1.0, size=(3))
    <span style="color: #a0522d;">d_old</span>   = drift(a,r_old)
    <span style="color: #a0522d;">d2_old</span>  = np.dot(d_old,d_old)
    <span style="color: #a0522d;">psi_old</span> = psi(a,r_old)

    <span style="color: #a020f0;">for</span> istep <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(nmax):
        <span style="color: #a0522d;">el</span> = e_loc(a,r_old)
        <span style="color: #a0522d;">w</span> *= np.exp(-dt*(el - Eref))

        <span style="color: #a0522d;">normalization</span> += w
        <span style="color: #a0522d;">energy</span>        += w * el

        <span style="color: #a0522d;">tau_current</span> += dt

        # <span style="color: #b22222;">Reset when tau is reached</span>
        <span style="color: #a020f0;">if</span> tau_current &gt;= tau:
            <span style="color: #a0522d;">w</span> = 1.
            <span style="color: #a0522d;">tau_current</span> = 0.

        <span style="color: #a0522d;">chi</span> = np.random.normal(loc=0., scale=1.0, size=(3))

        <span style="color: #a0522d;">r_new</span> = r_old + dt * d_old + sq_dt * chi
        <span style="color: #a0522d;">d_new</span> = drift(a,r_new)
        <span style="color: #a0522d;">d2_new</span> = np.dot(d_new,d_new)
        <span style="color: #a0522d;">psi_new</span> = psi(a,r_new)

        # <span style="color: #b22222;">Metropolis</span>
        <span style="color: #a0522d;">prod</span> = np.dot((d_new + d_old), (r_new - r_old))
        <span style="color: #a0522d;">argexpo</span> = 0.5 * (d2_new - d2_old)*dt + prod

        <span style="color: #a0522d;">q</span> = psi_new / psi_old
        <span style="color: #a0522d;">q</span> = np.exp(-argexpo) * q*q

        <span style="color: #a020f0;">if</span> np.random.uniform() &lt;= q:
            <span style="color: #a0522d;">N_accep</span> += 1
            <span style="color: #a0522d;">r_old</span>   = r_new
            <span style="color: #a0522d;">d_old</span>   = d_new
            <span style="color: #a0522d;">d2_old</span>  = d2_new
            <span style="color: #a0522d;">psi_old</span> = psi_new

    <span style="color: #a020f0;">return</span> energy/normalization, N_accep/nmax


# <span style="color: #b22222;">Run simulation</span>
<span style="color: #a0522d;">a</span>     = 0.9
<span style="color: #a0522d;">nmax</span>  = 100000
<span style="color: #a0522d;">dt</span>    = 0.1
<span style="color: #a0522d;">tau</span>   = 10.
<span style="color: #a0522d;">E_ref</span> = -0.5

<span style="color: #a0522d;">X0</span> = [ MonteCarlo(a, nmax, dt, tau, E_ref) <span style="color: #a020f0;">for</span> i <span style="color: #a020f0;">in</span> <span style="color: #483d8b;">range</span>(30)]

# <span style="color: #b22222;">Energy</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (x, _) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">E</span>, <span style="color: #a0522d;">deltaE</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"E = {E} +/- {deltaE}"</span>)

# <span style="color: #b22222;">Acceptance rate</span>
<span style="color: #a0522d;">X</span> = [ x <span style="color: #a020f0;">for</span> (_, x) <span style="color: #a020f0;">in</span> X0 ]
<span style="color: #a0522d;">A</span>, <span style="color: #a0522d;">deltaA</span> = ave_error(X)
<span style="color: #a020f0;">print</span>(f<span style="color: #8b2252;">"A = {A} +/- {deltaA}"</span>)
</pre>
</div>

<p>
<b>Fortran</b> 
</p>
<div class="org-src-container">
<pre class="src src-f90"><span style="color: #a020f0;">subroutine</span> <span style="color: #0000ff;">pdmc</span>(a, dt, nmax, energy, accep, tau, E_ref)
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> a, dt, tau</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> nmax </span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(out) ::<span style="color: #a0522d;"> energy, accep</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">intent</span>(in)  ::<span style="color: #a0522d;"> E_ref</span>

  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> istep</span>
  <span style="color: #228b22;">integer</span>*8        ::<span style="color: #a0522d;"> n_accep</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> sq_dt, chi(3), d2_old, prod, u</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> psi_old, psi_new, d2_new, argexpo, q</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> r_old(3), r_new(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> d_old(3), d_new(3)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> e, w, norm, tau_current</span>

  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">external</span> ::<span style="color: #a0522d;"> e_loc, psi</span>

  sq_dt = dsqrt(dt)

  ! <span style="color: #b22222;">Initialization</span>
  energy  = 0.d0
  n_accep = 0_8
  norm    = 0.d0

  w           = 1.d0
  tau_current = 0.d0

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_gauss</span>(r_old,3)

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">drift</span>(a,r_old,d_old)
  d2_old  = d_old(1)*d_old(1) + <span style="color: #a020f0;">&amp;</span>
            d_old(2)*d_old(2) + <span style="color: #a020f0;">&amp;</span>
            d_old(3)*d_old(3)

  psi_old = psi(a,r_old)

  <span style="color: #a020f0;">do</span> istep = 1,nmax
     e = e_loc(a,r_old)
     w = w * dexp(-dt*(e - E_ref))

     energy = energy + w*e
     norm   = norm + w

     tau_current = tau_current + dt

     ! <span style="color: #b22222;">Reset when tau is reached</span>
     <span style="color: #a020f0;">if</span> (tau_current &gt;= tau) <span style="color: #a020f0;">then</span>
        w = 1.d0
        tau_current = 0.d0
     <span style="color: #a020f0;">endif</span>

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_gauss</span>(chi,3)
     r_new(:) = r_old(:) + dt*d_old(:) + chi(:)*sq_dt

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">drift</span>(a,r_new,d_new)
     d2_new = d_new(1)*d_new(1) + <span style="color: #a020f0;">&amp;</span>
              d_new(2)*d_new(2) + <span style="color: #a020f0;">&amp;</span>
              d_new(3)*d_new(3)

     psi_new = psi(a,r_new)

     ! <span style="color: #b22222;">Metropolis</span>
     prod = (d_new(1) + d_old(1))*(r_new(1) - r_old(1)) + <span style="color: #a020f0;">&amp;</span>
            (d_new(2) + d_old(2))*(r_new(2) - r_old(2)) + <span style="color: #a020f0;">&amp;</span>
            (d_new(3) + d_old(3))*(r_new(3) - r_old(3))

     argexpo = 0.5d0 * (d2_new - d2_old)*dt + prod

     q = psi_new / psi_old
     q = dexp(-argexpo) * q*q

     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">random_number</span>(u)

     <span style="color: #a020f0;">if</span> (u &lt;= q) <span style="color: #a020f0;">then</span>

        n_accep = n_accep + 1_8

        r_old(:) = r_new(:)
        d_old(:) = d_new(:)
        d2_old   = d2_new
        psi_old  = psi_new

     <span style="color: #a020f0;">end if</span>

  <span style="color: #a020f0;">end do</span>

  energy = energy / norm
  accep  = <span style="color: #a020f0;">dble</span>(n_accep) / <span style="color: #a020f0;">dble</span>(nmax)

<span style="color: #a020f0;">end subroutine</span> <span style="color: #0000ff;">pdmc</span>

<span style="color: #a020f0;">program</span> <span style="color: #0000ff;">qmc</span>
  <span style="color: #a020f0;">implicit</span> <span style="color: #228b22;">none</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> a     = 0.9</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> dt    = 0.1d0</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> E_ref = -0.5d0</span>
  <span style="color: #228b22;">double precision</span>, <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> tau   = 10.d0</span>
  <span style="color: #228b22;">integer</span>*8       , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nmax  = 100000</span>
  <span style="color: #228b22;">integer</span>         , <span style="color: #a020f0;">parameter</span> ::<span style="color: #a0522d;"> nruns = 30</span>

  <span style="color: #228b22;">integer</span>          ::<span style="color: #a0522d;"> irun</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> X(nruns), accep(nruns)</span>
  <span style="color: #228b22;">double precision</span> ::<span style="color: #a0522d;"> ave, err</span>

  <span style="color: #a020f0;">do</span> irun=1,nruns
     <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">pdmc</span>(a, dt, nmax, X(irun), accep(irun), tau, E_ref)
  <span style="color: #a020f0;">enddo</span>

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(X,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'E = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

  <span style="color: #a020f0;">call</span> <span style="color: #0000ff;">ave_error</span>(accep,nruns,ave,err)
  <span style="color: #a020f0;">print</span> *, <span style="color: #8b2252;">'A = '</span>, ave, <span style="color: #8b2252;">'+/-'</span>, err

<span style="color: #a020f0;">end program</span> <span style="color: #0000ff;">qmc</span>
</pre>
</div>

<pre class="example">
E =  -0.50067519934141380      +/-   7.9390940184720371E-004
A =   0.98788066666666663      +/-   7.2889356133441110E-005

</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org182141b" class="outline-3">
<h3 id="org182141b"><span class="section-number-3">4.7</span> <span class="todo TODO">TODO</span> H<sub>2</sub></h3>
<div class="outline-text-3" id="text-4-7">
<p>
We will now consider the H<sub>2</sub> molecule in a minimal basis composed of the
\(1s\) orbitals of the hydrogen atoms:
</p>

<p>
\[
   \Psi(\mathbf{r}_1, \mathbf{r}_2) =
   \exp(-(\mathbf{r}_1 - \mathbf{R}_A)) + 
   \]
where \(\mathbf{r}_1\) and \(\mathbf{r}_2\) denote the electron
coordinates and \(\mathbf{R}_A\) and \(\mathbf{R}_B\) the coordinates of
the nuclei.
</p>
</div>
</div>
</div>


<div id="outline-container-org51ed78c" class="outline-2">
<h2 id="org51ed78c"><span class="section-number-2">5</span> <span class="todo TODO">TODO</span> <code>[0/3]</code> Last things to do</h2>
<div class="outline-text-2" id="text-5">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> Give some hints of how much time is required for each section</li>
<li class="off"><code>[&#xa0;]</code> Prepare 4 questions for the exam: multiple-choice questions
with 4 possible answers. Questions should be independent because
they will be asked in a random order.</li>
<li class="off"><code>[&#xa0;]</code> Propose a project for the students to continue the
programs. Idea: Modify the program to compute the exact energy of
the H\(_2\) molecule at $R$=1.4010 bohr. Answer: 0.17406 a.u.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Anthony Scemama, Claudia Filippi</p>
<p class="date">Created: 2021-01-29 Fri 12:24</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
